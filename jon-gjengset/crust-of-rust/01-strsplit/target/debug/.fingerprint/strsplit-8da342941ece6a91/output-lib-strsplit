{"message":"`&` without an explicit lifetime name cannot be used here","code":{"code":"E0637","explanation":"`'_` lifetime name or `&T` without an explicit lifetime name has been used\non illegal place.\n\nErroneous code example:\n\n```compile_fail,E0106,E0637\nfn underscore_lifetime<'_>(str1: &'_ str, str2: &'_ str) -> &'_ str {\n                     //^^ `'_` is a reserved lifetime name\n    if str1.len() > str2.len() {\n        str1\n    } else {\n        str2\n    }\n}\n\nfn and_without_explicit_lifetime<T>()\nwhere\n    T: Into<&u32>,\n          //^ `&` without an explicit lifetime name\n{\n}\n```\n\nFirst, `'_` cannot be used as a lifetime identifier in some places\nbecause it is a reserved for the anonymous lifetime. Second, `&T`\nwithout an explicit lifetime name cannot also be used in some places.\nTo fix them, use a lowercase letter such as `'a`, or a series\nof lowercase letters such as `'foo`. For more information about lifetime\nidentifier, see [the book][bk-no]. For more information on using\nthe anonymous lifetime in Rust 2018, see [the Rust 2018 blog post][blog-al].\n\nCorrected example:\n\n```\nfn underscore_lifetime<'a>(str1: &'a str, str2: &'a str) -> &'a str {\n    if str1.len() > str2.len() {\n        str1\n    } else {\n        str2\n    }\n}\n\nfn and_without_explicit_lifetime<'foo, T>()\nwhere\n    T: Into<&'foo u32>,\n{\n}\n```\n\n[bk-no]: https://doc.rust-lang.org/book/appendix-02-operators.html#non-operator-symbols\n[blog-al]: https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#more-lifetime-elision-rules\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":275,"byte_end":276,"line_start":13,"line_end":13,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"    type Item = &str;","highlight_start":17,"highlight_end":18}],"label":"explicit lifetime name needed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0637]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: `&` without an explicit lifetime name cannot be used here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:13:17\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    type Item = &str;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexplicit lifetime name needed here\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":170,"byte_end":174,"line_start":6,"line_end":6,"column_start":53,"column_end":57,"is_primary":true,"text":[{"text":"    pub fn new( haystack: &str, delimiter: &str) -> Self {}","highlight_start":53,"highlight_end":57}],"label":"expected `StrSplit`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\lib.rs","byte_start":129,"byte_end":132,"line_start":6,"line_end":6,"column_start":12,"column_end":15,"is_primary":false,"text":[{"text":"    pub fn new( haystack: &str, delimiter: &str) -> Self {}","highlight_start":12,"highlight_end":15}],"label":"implicitly returns `()` as its body has no tail or `return` expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: mismatched types\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:6:53\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new( haystack: &str, delimiter: &str) -> Self {}\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m---\u001b[0m\u001b[0m                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `StrSplit`, found `()`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimplicitly returns `()` as its body has no tail or `return` expression\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":308,"byte_end":326,"line_start":14,"line_end":14,"column_start":27,"column_end":45,"is_primary":true,"text":[{"text":"    fn next(&mut self) -> Option<Self::Item> {}","highlight_start":27,"highlight_end":45}],"label":"expected `Option<&str>`, found `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src\\lib.rs","byte_start":289,"byte_end":293,"line_start":14,"line_end":14,"column_start":8,"column_end":12,"is_primary":false,"text":[{"text":"    fn next(&mut self) -> Option<Self::Item> {}","highlight_start":8,"highlight_end":12}],"label":"implicitly returns `()` as its body has no tail or `return` expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"  expected enum `Option<&str>`\nfound unit type `()`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:14:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn next(&mut self) -> Option<Self::Item> {}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m----\u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Option<&str>`, found `()`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mimplicitly returns `()` as its body has no tail or `return` expression\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m:   expected enum `\u001b[0m\u001b[0m\u001b[1mOption<&str>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m           found unit type `\u001b[0m\u001b[0m\u001b[1m()\u001b[0m\u001b[0m`\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0308, E0637.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0308, E0637.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0308`.\u001b[0m\n"}
